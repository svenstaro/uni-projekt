// addressrange.sip generated by MetaSIP on Mon Oct  8 00:06:00 2012
//
// This file is part of the okteta Python extension module.
//
// Copyright (C) 2012 Shaheed Haque <srhaque@theiet.org>
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) version 3.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Library General Public License for more details.
//
// You should have received a copy of the GNU Library General Public License
// along with this library; see the file COPYING.LIB.  If not, write to
// the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.


// // Manually mapped via MetaSIP
// See http://code.activestate.com/lists/python-list/313958/
// and see http://trac.assembla.com/pkaudio/wiki/STLVectorForSip

%MappedType KDE::NumberRange<int, int>
{
//%HeaderCode
//#include <<the header for the template class>>
//#include <<any other headers you need>>
// you can stick a typedef here if you want
// to create a new name for the template type
//%End

%ConvertFromTypeCode
    // sipCpp will contain a pointer to the template
    // object. You want to take sipCpp and convert
    // it into some PyObject(s) and return those
    // at the end of this section. Since this is
    // in C/C++, you have to use Py_BuildValue if
    // you need to return more than a single Python
    // object (returns a tuple - a list of Python
    // objects is a single object though). sipCpp
    // can be null too, so test for that.
    PyObject *list = PyList_New (0);

    if (sipCpp) {
        KDE::NumberRange<int, int> *cppObj = (KDE::NumberRange<int, int> *)sipCpp;

        // Go through each element in the C++ instance and convert it to a wrapped object.
        PyList_SET_ITEM(list, 0, PyInt_FromLong(cppObj->start()));
        PyList_SET_ITEM(list, 1, PyInt_FromLong(cppObj->end()));
    }
    return list; // empty if sipCpp == 0
%End

%ConvertToTypeCode
    // sipPy will contain a pointer to the PyObject.
    // Convert that to the corresponding C/C++
    // object and set sipCppPtr to point to that.
    // Return 1 on success or 0 on failure

    // Check if type is compatible. Must be any iterable.
    PyObject *iterator = PyObject_GetIter(sipPy);
    if (!iterator) {
        Py_XDECREF(iterator);
        PyErr_Format(PyExc_TypeError, "object not iterable cannot be converted to KDE::NumberRange<int, int>");
        *sipIsErr = 1;
        return 0;
   }

    // Iterate over the object
    if (2 == PyObject_Size(sipPy)) {
        PyObject *pyStart = PyIter_Next(iterator);
        PyObject *pyEnd = PyIter_Next(iterator);
        if (PyInt_Check(pyStart) && PyInt_Check(pyEnd)) {
            *sipCppPtr = new KDE::NumberRange<int, int>(PyInt_AsLong(pyStart), PyInt_AsLong(pyEnd));
        } else {
            PyErr_Format(PyExc_TypeError, "object in iterable cannot be converted to int");
            *sipIsErr = 1;
        }
        Py_DECREF(pyStart);
        Py_DECREF(pyEnd);
    }
    Py_DECREF(iterator);
    if (*sipIsErr) {
           return 0;
    }
    return sipGetState(sipTransferObj);
%End

};

namespace Okteta
{
%TypeHeaderCode
#include <addressrange.h>
%End

    typedef KDE::NumberRange<int, int> AddressRange;
};
