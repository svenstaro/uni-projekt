
\section{ISA(Felix O.\&Marcel\&Felix W.)}

Den Aufbau unserer Instrution Set Architecture haben wir bereits beim ersten Gruppentreffen begonnen und stark umstritten. Im Verlauf des Projekts hat sich viel geändert, zum Teil motiviert durch Wünsche und Verbessungsideen unserer Mitglieder, zum Teil begründet in Fehlern oder Problemen mit den Befehlsworten oder deren Bitcode-Layout.
In der \autoref{AP:ISA} ist unsere endgültige Instruction Set Architecture zu sehen. Wir haben von Beginn an den Fokus auf eine überschaubare Komplexität gelegt. Unsere arithmetischen Operationen zum Beispiel enthalten nur Befehle für Addition, Subtraktion und Multiplikation. Division haben wir nicht behandelt, da das ein tiefergehendes Auseinandersetzen mit Gleitkommazahlen nach sich gezogen hätte. \todo{Das ist Quark} Gleitkomma-Arithmetik haben wir von Beginn an als schwieriges, nicht notwendiges Feature eingestuft.

Für die Speicherzugriffsbefehle nutzen wir lediglich kustomisierte Varienten von load und store. Bemerkenswert ist jedoch unser breites Angebot an Sprungbefehlen. Diese haben wir so definiert, dass sie auf Labels referenzieren können. Labels sind in unserem Assembler Punkte im Code, die einen funktional zusammengehörigen Block markieren. Dies war am Anfang des Semesters noch völlig offen und hat sich erst mit der Zeit ergeben. Die Verwendung von Labels hatten wir zunächst, ähnlich wie die Gleitkomma-Arithmetik, als nicht so wichtig eingestuft. Für viele Programmabläufe sind Sprünge jedoch unabdingbar und daher umso dringender als Kommando im Assembler benötigt. Das endgültige Design der Springbefehle ist derart gestaltet, dass sie konditionierbar sind; die bekannte Befehle, die bei einer Vergleichsoperation ausgelöst werden können, etwa jump-less-or-equal, haben wir um Befehle erweitert, die auf jedem Statusflag-Status unserer ALU aufsetzen. So gibt es beispielsweise einen Jump-Befehl für den Overflow Fall, der aus Rahmen eines herkömmlichen Minimalassemblers herausfällt.
Schlussendlich haben sich in unserer ISA auch noch Befehle als nützlich erwiesen, die eine spezielle Funktion direkt an der Hardware abstrahieren. Die ISA bietet uns die Möglichkeit direkt auf Buttons und LEDs auf dem FPGA zuzugreifen und diese Hardwarelemente in logisch unären Operationen anzusprechen. Dies ist sehr praktisch, denn eine Abfrage der Buttonelemente für jedes Programm als Sprachkonstrukt in herkömmlichem Assembler implementieren zu müssen, erschien uns sehr umständlich.

All diese Feinheiten der ISA haben sich mit der Zeit entwickelt. Beginnend bei unserem Primärziel, ein FPGA zu einem kleinen Taschenrechner werden lassen, hatten wir eine entsprechend kleine ISA. Sie umfasste lediglich den Befehlsatz für arithmetische Operationen, der fast genau so bis zur endgültigen ISA geblieben ist, Kontrollfluss regulierende Befehle wie call und jump, die wir zu diesem Zeitpunkt noch nicht weiter durchdacht hatten, sowie einen load und store Befehl. Wie \autoref{AP:ISA} zeigt, hat sich die ISA im Vergleich zu \autoref{gen:Idee} stark erweitert.

% TODO: entwicklung zur final isa
% probleme am anfang
% probleme zwischendurch
% geil am ende

\section{Emulator(Felix W.)}
% TODO: do your shit

\section{Assembler(Felix W.)}
% TODO: do your shit
% inkl. programmbeispiele

\section{GUI/Debugger(Marcel)}
% TODO: do your shit

