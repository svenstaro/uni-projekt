\section{ISA}
Den Aufbau unserer Instruction Set Architecture haben wir bereits beim ersten Gruppentreffen begonnen und stark umstritten.
Im Verlauf des Projekts hat sich viel geändert, zum Teil motiviert durch Wünsche und Verbessungsideen unserer Mitglieder,
zum Teil begründet in Fehlern oder Problemen mit den Befehlsworten oder deren Bitcode-Layout, um die Interpretation des Binärcodes in der Hardware zu vereinfachen.
In der \autoref{AP:ISA} ist unsere endgültige Instruction Set Architecture zu sehen.

Von Beginn an war ein Reduced Instruction Set (RISC) mit drei Operanden-Befehlen geplant.
Die Wortbreite beträgt 32-bit. Es gibt 15 General Purpose-Register, wovon zwei zum Speichern des Stack Pointers und der Rücksprungaddresse genutzt werden.
Das erste Register \texttt{\$0} ist immer null und kann auch zum Verwerfen eines Ergebnisses genutzt werden, in dem es als Zielregister angegeben wird.
Es gibt vier Statusflags -- Zero, Negative, Carry, Overflow.
Diese können von allen ALU-Befehlen gesetzt werden und für konditionierte Sprünge genutzt werden.
Mit dem \texttt{\$0}-Register und den Statusflags werden Vergleiche nun als Substraktionen modelliert:
Der Befehl \texttt{cmp \$1, \$2} wird übersetzt zu \texttt{subs \$0, \$1, \$2} --
also eine Substraktion, bei der die Statusflags abhängig vom Ergebnis gesetzt werden, und das Ergebnis in \texttt{\$0} gespeichert wird. \\
Alle ALU-Befehle können auch mit einem 16-Bit-Immediate als dritten Operanden genutzt werden.
In der finalen Version der ISA exisitiert kein Divisionsbefehl, da dieser zu Gunsten anderer Bitmasken-Befehle fallengelassen wurde.
Zudem gibt es keine Multiplikation, die ein 64-bittes Ergebnis hat.

Für Speicherzugriffe gibt es zwei Load- und Store-Befehle zum Lesen und Speichern von 32-Bit-Wörtern --
die Speicheraddressen müssen dabei kein Vielfaches der Wortbreite sein.
Die Angabe der Speicheraddresse ist entweder absolut mittels eines Registers oder relativ zum Program Counter mit einem 24-Bit-Immediate.
Eine relativer Zugriff mit einem Register ist so nicht direkt möglich, aber der \texttt{adr}-Befehl kann für etwaige Addressberechnungen verwendet werden.
Zusätzlich gibt es die zwei Spezialbefehle \texttt{push} und \texttt{pop}, um die Stacknutzung zu beschleunigen.

Die Sprungbefehle sind ähnlich gehalten wie die Speicherbefehle und
können entweder absolut springen mit einem Registerwert oder PC-relativ mit einem 24-Bit-Immediate.
Zudem sind alle Sprungbefehle bedingt von den Statusflags.
Die Sprungbedingung ist eine Veroderung von einer beliebigen Teilmenge von Statusflags beziehungsweise eine Negation davon.
Hiermit können alle wichtigen Bedingungen dargestellt werden:
Ein positives Ergebnis lag zum Beispiel vor, wenn $\neg (\texttt{Negative} \lor \texttt{Zero})$ gilt.
Auch hier gibt es wieder einen Spezialbefehl zur Beschleunigung typischer Assemblerprogramme: den \texttt{call}-Befehl.
Diesen gibt es nur in der Ausführung PC-relativ mit Immediate.
Er speichert gleichzeitig den Wert \texttt{PC+4} im Rücksprungregister und
eignet sich damit hervorragend für Subroutinenaufrufe.

%TODO
Schlussendlich haben sich in unserer ISA auch noch Befehle als nützlich erwiesen, die eine spezielle Funktion direkt an der Hardware abstrahieren. Die ISA bietet uns die Möglichkeit direkt auf Buttons und LEDs auf dem FPGA zuzugreifen und diese Hardwarelemente in logisch unären Operationen anzusprechen. Dies ist sehr praktisch, denn eine Abfrage der Buttonelemente für jedes Programm als Sprachkonstrukt in herkömmlichem Assembler implementieren zu müssen, erschien uns sehr umständlich.

All diese Feinheiten der ISA haben sich mit der Zeit entwickelt. Beginnend bei unserem Primärziel, ein FPGA zu einem kleinen Taschenrechner werden lassen, hatten wir eine entsprechend kleine ISA. Sie umfasste lediglich den Befehlsatz für arithmetische Operationen, der fast genau so bis zur endgültigen ISA geblieben ist, Kontrollfluss regulierende Befehle wie call und jump, die wir zu diesem Zeitpunkt noch nicht weiter durchdacht hatten, sowie einen load und store Befehl. Wie \autoref{AP:ISA} zeigt, hat sich die ISA im Vergleich zu \autoref{gen:Idee} stark erweitert. \todo{calculator.s in Anhang und referenzieren}

\newpage
\begin{multicols}{3}
\inputminted{nasm}{calc.s}
\end{multicols}


% TODO: entwicklung zur final isa
% probleme am anfang
%  - 
% probleme zwischendurch: fehlendes adr, absolut <-> relativ bei Sprüngen und Speicherbefehlen
% geil am ende

\section{ABI}
% TODO
% Parameter: $1, $2, $3, $4, Stack
% Rückgabe: $1
% (Stackpointer: $14, Rücksprungaddresse: $15)
% Caller-Save: $1,$2,$3,$4, $15
% Calle-Save: $5-$14

\section{Assembler} % Felix W.
% TODO: do your shit
% inkl. programmbeispiele
% faculty.s mit Kommentaren

\section{Emulator} % Felix W.
% TODO: do your shit
% intention: hardware nicht so weit. wollten isa und abi testen auf tauglichkeit
% assembler testen

\section{GUI/Debugger(Marcel)}
% TODO: do your shit

% TODO: calculator.s mit Kommentaren im Anhang
