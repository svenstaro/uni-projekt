// File: processor.v
// Generated by MyHDL 0.9dev
// Date: Mon Jan 27 10:01:23 2014


`timescale 1ns/10ps

module processor (
    clk,
    reset,
    buttons,
    leds,
    rx,
    tx,
    memoryaddr,
    memoryin,
    memoryout,
    romrden,
    ramrden,
    ramwren,
    fifodata,
    fifore,
    fifowe,
    fifoempty,
    fifofull,
    fifoq
);
// clk        (Ibool)  -- The clock
// reset      (IReset) -- Reset Signal
// buttons    (I4)     -- 4 input buttons
// leds       (O4)     -- 4 output LEDS
// rx         (Ibool)  -- input from rs232
// tx         (Obool)  -- output from rs232
// memoryaddr (O16)    -- memory addr
// memoryin   (I32)    -- memory read
// memoryout  (O32)    -- memory write
// romrden    (Obool)  -- rom-readenable
// ramrden    (Obool)  -- ram-readenable
// ramwren    (Obool)  -- ram-writeenable
// fifodata   (O8)     -- fifo data in
// fifore     (Obool)  -- enable reading from fifo
// fifowe     (Obool)  -- enable writing to fifo
// fifoempty  (Ibool)  -- indicates, that fifo is empty
// fifofull   (Ibool)  -- indicates, that the fifo is full
// fifoq      (I8)     -- fifo data out
// 
// baudrate           -- the baudrate for the rs232
// enCache            -- enable cache or not
// interesting        -- A list with interesting signals will be returned

input clk;
input reset;
input [3:0] buttons;
output [3:0] leds;
reg [3:0] leds;
input rx;
output tx;
reg tx;
output [15:0] memoryaddr;
reg [15:0] memoryaddr;
input [31:0] memoryin;
wire [31:0] memoryin;
output [31:0] memoryout;
reg [31:0] memoryout;
output romrden;
wire romrden;
output ramrden;
wire ramrden;
output ramwren;
wire ramwren;
output [7:0] fifodata;
reg [7:0] fifodata;
output fifore;
wire fifore;
output fifowe;
reg fifowe;
input fifoempty;
input fifofull;
input [7:0] fifoq;

wire [3:0] irSource;
reg enJump;
reg enCall;
reg [31:0] rgX;
reg [31:0] rgY;
reg bufOp2;
reg cIn;
reg bufClk;
reg bufRy;
wire [31:0] pcOut;
reg rstreadybit;
wire [31:0] bbus;
reg readybit;
reg enReg;
wire [23:0] irImm24;
reg nIn;
wire [3:0] irSource2;
reg bufAddr;
wire irSup;
reg bufRsr;
reg mmuBuf;
reg enPc;
reg addrymux1;
reg addrymux0;
wire [3:0] irAluop;
wire [4:0] irJumpOp;
reg enRst;
reg bufPC;
reg bufBut;
reg bufAddr14;
reg enAlu;
wire [6:0] irPrefix;
wire irOp1;
wire irOp2;
reg zIn;
reg bufAlu;
reg enSup;
wire nOut;
wire cOut;
wire [3:0] irDest;
reg enMmu;
wire vOut;
reg enIr;
wire zOut;
reg enLed;
reg pmux;
reg vIn;
reg jumpResult;
wire [15:0] irImm16;
reg Memory_csO;
reg Memory_csA;
reg [31:0] Memory_mmuOut;
reg Memory_enW;
reg Memory_enO;
wire [31:0] Memory_mmuTristate_o;
reg [7:0] Memory_Mmu_waitingtimer;
reg [1:0] Memory_Mmu_state;
reg [31:0] Memory_Mmu_in_data;
reg Memory_Mmu_with_data;
reg [31:0] IO_ioOut;
wire [31:0] IO_ioTristate_o;
reg [3:0] IO_io_ledBuffer;
reg [3:0] RS232_reader_bitCnt;
reg [0:0] RS232_reader_state;
reg [10:0] RS232_reader_clkCnt;
reg [7:0] RS232_reader_data;
reg [3:0] RS232_writer_bitCnt;
reg [0:0] RS232_writer_state;
reg [31:0] RS232_writer_clkCnt;
reg [7:0] RS232_writer_data;
wire [31:0] RS232_readerTristate_o;
wire [31:0] ClkBuf_clkOut;
reg [31:0] ClkBuf_clock_data;
wire [31:0] ClkBuf_clkTristate_o;
wire [31:0] AddrBuf_addrMuxOut;
wire [31:0] AddrBuf_addOut;
wire [31:0] AddrBuf_addrTristate_o;
wire [31:0] Op2Buf_op2muxOut;
wire [31:0] Op2Buf_op2tristate_o;
wire [31:0] Addr14Buf_addr14;
wire [31:0] Addr14Buf_plusminusMuxOut;
wire [31:0] Addr14Buf_addr14tristate_o;
wire [31:0] PC_pcTristate_o;
reg [31:0] PC_pc_data;
wire [31:0] ALU_BmuxOut;
reg [31:0] ALU_aluRes;
wire [31:0] ALU_aluTristate_o;
reg [3:0] RegisterBank_zMuxOut;
reg [3:0] RegisterBank_yMuxOut;
wire [31:0] RegisterBank_ryTristate_o;
wire StatusFlags_sUp;
reg [0:0] StatusFlags_V_data;
reg [0:0] StatusFlags_C_data;
reg [0:0] StatusFlags_N_data;
reg [0:0] StatusFlags_Z_data;
wire CPU_ffavail;
reg [3:0] CPU_Cpu_substate;
reg [4:0] CPU_Cpu_state;
wire [31:0] IR_ir2idecoder;
reg [31:0] IR_ir_data;

reg [31:0] RegisterBank_rb_reg_data [0:16-1];


assign bbus = RegisterBank_ryTristate_o;
assign bbus = ALU_aluTristate_o;
assign bbus = PC_pcTristate_o;
assign bbus = Addr14Buf_addr14tristate_o;
assign bbus = Op2Buf_op2tristate_o;
assign bbus = AddrBuf_addrTristate_o;
assign bbus = ClkBuf_clkTristate_o;
assign bbus = RS232_readerTristate_o;
assign bbus = IO_ioTristate_o;
assign bbus = Memory_mmuTristate_o;


function integer MYHDL31_calc;
    input [4-1:0] opc;
    input [32-1:0] first;
    input [32-1:0] second;
    input [1-1:0] c;
begin: MYHDL51_RETURN
    case (opc)
        'h0: begin
            MYHDL31_calc = (first + second);
            disable MYHDL51_RETURN;
        end
        'h1: begin
            MYHDL31_calc = ((first + second) + c);
            disable MYHDL51_RETURN;
        end
        'h4: begin
            MYHDL31_calc = ($signed({1'b0, first}) - $signed({1'b0, second}));
            disable MYHDL51_RETURN;
        end
        'h5: begin
            MYHDL31_calc = (($signed({1'b0, first}) - $signed({1'b0, second})) - c);
            disable MYHDL51_RETURN;
        end
        'h6: begin
            MYHDL31_calc = ($signed({1'b0, second}) - $signed({1'b0, first}));
            disable MYHDL51_RETURN;
        end
        'h7: begin
            MYHDL31_calc = ((second + c) - first);
            disable MYHDL51_RETURN;
        end
        'h2: begin
            MYHDL31_calc = (first * second);
            disable MYHDL51_RETURN;
        end
        'h3: begin
            MYHDL31_calc = (first & (~second));
            disable MYHDL51_RETURN;
        end
        'h8: begin
            MYHDL31_calc = (first & second);
            disable MYHDL51_RETURN;
        end
        'h9: begin
            MYHDL31_calc = (first | second);
            disable MYHDL51_RETURN;
        end
        'ha: begin
            MYHDL31_calc = (first ^ second);
            disable MYHDL51_RETURN;
        end
        'hb: begin
            MYHDL31_calc = (first | (~second));
            disable MYHDL51_RETURN;
        end
        'hc: begin
            if ((second < 32) !== 1) begin
                $display("*** AssertionError ***");
            end
            MYHDL31_calc = (first << second);
            disable MYHDL51_RETURN;
        end
        'hd: begin
            if ((second < 32) !== 1) begin
                $display("*** AssertionError ***");
            end
            MYHDL31_calc = $signed($signed(first) >>> second);
            disable MYHDL51_RETURN;
        end
        'he: begin
            if ((second < 32) !== 1) begin
                $display("*** AssertionError ***");
            end
            MYHDL31_calc = (first >>> second);
            disable MYHDL51_RETURN;
        end
        default: begin
            if ((second < 32) !== 1) begin
                $display("*** AssertionError ***");
            end
            MYHDL31_calc = (($signed({1'b0, first}) << (32 - $signed({1'b0, second}))) | (first >>> second));
            disable MYHDL51_RETURN;
        end
    endcase
end
endfunction



assign CPU_ffavail = (!fifoempty);



assign fifore = bufRsr;


always @(posedge clk, negedge reset) begin: PROCESSOR_CPU_CPU_LOGIC
    if (reset == 0) begin
        enJump <= 0;
        bufAddr14 <= 0;
        CPU_Cpu_substate <= 0;
        enCall <= 0;
        enPc <= 0;
        enReg <= 0;
        bufAddr <= 0;
        enMmu <= 0;
        bufRy <= 0;
        bufBut <= 0;
        bufClk <= 0;
        CPU_Cpu_state <= 5'b00001;
        mmuBuf <= 0;
        addrymux1 <= 0;
        addrymux0 <= 0;
        enAlu <= 0;
        bufPC <= 0;
        bufOp2 <= 0;
        pmux <= 0;
        bufAlu <= 0;
        enIr <= 0;
        enRst <= 0;
        enLed <= 0;
        enSup <= 0;
        bufRsr <= 0;
    end
    else begin
        addrymux1 <= 1'b0;
        addrymux0 <= 1'b0;
        pmux <= 1'b0;
        bufAddr <= 1'b0;
        bufOp2 <= 1'b0;
        bufAddr14 <= 1'b0;
        bufRy <= 1'b0;
        bufAlu <= 1'b0;
        bufPC <= 1'b0;
        bufClk <= 1'b0;
        bufBut <= 1'b0;
        bufRsr <= 1'b0;
        enAlu <= 1'b0;
        enIr <= 1'b0;
        enPc <= 1'b0;
        enReg <= 1'b0;
        enSup <= 1'b0;
        enJump <= 1'b0;
        enCall <= 1'b0;
        enLed <= 1'b0;
        enRst <= 1'b0;
        enMmu <= 1'b0;
        mmuBuf <= 1'b0;
        
        case (CPU_Cpu_state)
            5'b00000: begin
                if ((irPrefix[7-1:5] == 0)) begin
                    CPU_Cpu_state <= 5'b00011;
                end
                else if ((irPrefix[7-1:5] == 1)) begin
                    CPU_Cpu_state <= 5'b00100;
                end
                else if ((irPrefix[7-1:4] == 4)) begin
                    CPU_Cpu_state <= 5'b00101;
                end
                else if ((irPrefix[7-1:4] == 5)) begin
                    CPU_Cpu_state <= 5'b00110;
                end
                else if ((irPrefix[7-1:4] == 6)) begin
                    CPU_Cpu_state <= 5'b00111;
                end
                else if ((irPrefix[7-1:2] == 28)) begin
                    CPU_Cpu_state <= 5'b01000;
                end
                else if ((irPrefix[7-1:2] == 29)) begin
                    CPU_Cpu_state <= 5'b01001;
                end
                else if ((irPrefix[7-1:1] == 60)) begin
                    CPU_Cpu_state <= 5'b01010;
                end
                else if ((irPrefix[7-1:1] == 61)) begin
                    CPU_Cpu_state <= 5'b01011;
                end
                else if ((irPrefix[7-1:0] == 124)) begin
                    CPU_Cpu_state <= 5'b01101;
                end
                else if ((irPrefix[7-1:0] == 125)) begin
                    CPU_Cpu_state <= 5'b01100;
                end
                else if ((irPrefix[7-1:0] == 126)) begin
                    CPU_Cpu_state <= 5'b01110;
                end
                else if ((irPrefix[7-1:0] == 127)) begin
                    CPU_Cpu_state <= 5'b01111;
                end
                else begin
                    CPU_Cpu_state <= 5'b10001;
                end
            end
            5'b00001: begin
                if (((!readybit) && (CPU_Cpu_substate == 0))) begin
                    // pass
                end
                else begin
                    if ((CPU_Cpu_substate == 0)) begin
                        enMmu <= 1'b1;
                        bufPC <= 1'b1;
                        CPU_Cpu_substate <= (CPU_Cpu_substate + 1);
                    end
                    else if ((CPU_Cpu_substate == 1)) begin
                        CPU_Cpu_substate <= (CPU_Cpu_substate + 1);
                    end
                    else if ((!readybit)) begin
                        // pass
                    end
                    else if (readybit) begin
                        mmuBuf <= 1'b1;
                        enIr <= 1'b1;
                        CPU_Cpu_substate <= 0;
                        CPU_Cpu_state <= 5'b00010;
                    end
                end
            end
            5'b00010: begin
                enPc <= 1'b1;
                CPU_Cpu_state <= 5'b00000;
            end
            5'b00011: begin
                enAlu <= 1'b1;
                bufAlu <= 1'b1;
                enReg <= 1'b1;
                enSup <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b00100: begin
                enJump <= 1'b1;
                enPc <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b00101: begin
                if (((!readybit) && (CPU_Cpu_substate == 0))) begin
                    // pass
                end
                else begin
                    if ((CPU_Cpu_substate == 0)) begin
                        enMmu <= 1'b1;
                        bufAddr <= 1'b1;
                        CPU_Cpu_substate <= (CPU_Cpu_substate + 1);
                    end
                    else if ((CPU_Cpu_substate == 1)) begin
                        CPU_Cpu_substate <= (CPU_Cpu_substate + 1);
                    end
                    else if ((!readybit)) begin
                        // pass
                    end
                    else if (readybit) begin
                        mmuBuf <= 1'b1;
                        enReg <= 1'b1;
                        CPU_Cpu_substate <= 0;
                        CPU_Cpu_state <= 5'b00001;
                    end
                end
            end
            5'b00110: begin
                if (((!readybit) && (CPU_Cpu_substate == 0))) begin
                    // pass
                end
                else begin
                    case (CPU_Cpu_substate)
                        'h0: begin
                            addrymux0 <= 1'b1;
                            addrymux1 <= 1'b1;
                            bufRy <= 1'b1;
                            enMmu <= 1'b1;
                        end
                        'h1: begin
                            CPU_Cpu_substate <= 1;
                            bufOp2 <= 1'b1;
                            enMmu <= 1'b1;
                            CPU_Cpu_substate <= 0;
                            CPU_Cpu_state <= 5'b00001;
                        end
                    endcase
                end
            end
            5'b00111: begin
                enReg <= 1'b1;
                bufAddr <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b01000: begin
                if (((!readybit) && (CPU_Cpu_substate == 0))) begin
                    // pass
                end
                else begin
                    case (CPU_Cpu_substate)
                        'h0: begin
                            addrymux1 <= 1'b1;
                            pmux <= 1'b0;
                            enReg <= 1'b1;
                            bufAddr14 <= 1'b1;
                            CPU_Cpu_substate <= 1;
                        end
                        'h1: begin
                            addrymux1 <= 1'b1;
                            bufRy <= 1'b1;
                            enMmu <= 1'b1;
                            CPU_Cpu_substate <= 2;
                        end
                        'h2: begin
                            bufOp2 <= 1'b1;
                            enMmu <= 1'b1;
                            CPU_Cpu_substate <= 0;
                            CPU_Cpu_state <= 5'b00001;
                        end
                    endcase
                end
            end
            5'b01001: begin
                if (((!readybit) && (CPU_Cpu_substate == 0))) begin
                    // pass
                end
                else begin
                    if ((CPU_Cpu_substate == 0)) begin
                        addrymux1 <= 1'b1;
                        bufRy <= 1'b1;
                        enMmu <= 1'b1;
                        CPU_Cpu_substate <= 1;
                    end
                    else if ((CPU_Cpu_substate == 1)) begin
                        addrymux1 <= 1'b1;
                        pmux <= 1'b1;
                        enReg <= 1'b1;
                        bufAddr14 <= 1'b1;
                        CPU_Cpu_substate <= 2;
                    end
                    else if ((!readybit)) begin
                        // pass
                    end
                    else if (readybit) begin
                        mmuBuf <= 1'b1;
                        addrymux1 <= 1'b1;
                        addrymux0 <= 1'b1;
                        enReg <= 1'b1;
                        CPU_Cpu_substate <= 0;
                        CPU_Cpu_state <= 5'b00001;
                    end
                end
            end
            5'b01010: begin
                case (CPU_Cpu_substate)
                    'h0: begin
                        bufPC <= 1'b1;
                        addrymux0 <= 1'b1;
                        enReg <= 1'b1;
                        CPU_Cpu_substate <= 1;
                    end
                    'h1: begin
                        enCall <= 1'b1;
                        enPc <= 1'b1;
                        CPU_Cpu_substate <= 0;
                        CPU_Cpu_state <= 5'b00001;
                    end
                endcase
            end
            5'b01011: begin
                bufClk <= 1'b1;
                addrymux0 <= 1'b1;
                addrymux1 <= 1'b1;
                enReg <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b01100: begin
                enLed <= 1'b1;
                bufOp2 <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b01101: begin
                addrymux0 <= 1'b1;
                addrymux1 <= 1'b1;
                enReg <= 1'b1;
                bufBut <= 1'b1;
                CPU_Cpu_state <= 5'b00001;
            end
            5'b01110: begin
                if (CPU_ffavail) begin
                    bufRsr <= 1'b1;
                    addrymux0 <= 1'b1;
                    addrymux1 <= 1'b1;
                    enReg <= 1'b1;
                    CPU_Cpu_state <= 5'b00001;
                end
            end
            5'b01111: begin
                if ((CPU_Cpu_substate <= 2)) begin
                    enRst <= 1'b1;
                    bufOp2 <= 1'b1;
                    CPU_Cpu_substate <= (CPU_Cpu_substate + 1);
                end
                else if (rstreadybit) begin
                    CPU_Cpu_substate <= 0;
                    CPU_Cpu_state <= 5'b00001;
                end
            end
            5'b10000: begin
                CPU_Cpu_state <= 5'b10000;
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end



assign Addr14Buf_plusminusMuxOut = pmux ? 4 : (-4);



assign Addr14Buf_addr14 = ($signed(Addr14Buf_plusminusMuxOut) + $signed(rgY));



assign Addr14Buf_addr14tristate_o = bufAddr14 ? Addr14Buf_addr14 : 'bz;



assign ClkBuf_clkTristate_o = bufClk ? ClkBuf_clkOut : 'bz;


always @(posedge clk, negedge reset) begin: PROCESSOR_CLKBUF_CLOCK_WRITE
    if (reset == 0) begin
        ClkBuf_clock_data <= 0;
    end
    else begin
        ClkBuf_clock_data <= 1 ? (ClkBuf_clock_data + 1) : ClkBuf_clock_data;
    end
end



assign ClkBuf_clkOut = ClkBuf_clock_data;


always @(posedge clk, negedge reset) begin: PROCESSOR_PC_PC_WRITE
    if (reset == 0) begin
        PC_pc_data <= 0;
    end
    else begin
        if (enPc) begin
            if ((!(enCall || enJump))) begin
                PC_pc_data <= (PC_pc_data + 4);
            end
            else if ((enCall || (enJump && jumpResult))) begin
                PC_pc_data <= irOp1 ? ($signed({1'b0, PC_pc_data}) + $signed(irImm24)) : rgY;
            end
        end
    end
end



assign pcOut = PC_pc_data;



assign PC_pcTristate_o = bufPC ? pcOut : 'bz;



assign AddrBuf_addOut = ($signed(pcOut) + $signed(irImm24));



assign AddrBuf_addrMuxOut = irOp1 ? AddrBuf_addOut : rgY;



assign AddrBuf_addrTristate_o = bufAddr ? AddrBuf_addrMuxOut : 'bz;



assign RS232_readerTristate_o = bufRsr ? fifoq : 'bz;


always @(posedge clk, negedge reset) begin: PROCESSOR_RS232_READER_LOGIC
    if (reset == 0) begin
        fifowe <= 0;
        fifodata <= 0;
        RS232_reader_bitCnt <= 0;
        RS232_reader_state <= 1'b0;
        RS232_reader_clkCnt <= 0;
        RS232_reader_data <= 0;
    end
    else begin
        if ((RS232_reader_clkCnt > 0)) begin
            RS232_reader_clkCnt <= (RS232_reader_clkCnt - 1);
        end
        else begin
            case (RS232_reader_state)
                1'b0: begin
                    if ((!rx)) begin
                        RS232_reader_data <= 0;
                        RS232_reader_bitCnt <= 8;
                        RS232_reader_clkCnt <= 1301;
                        fifowe <= 1'b0;
                        RS232_reader_state <= 1'b1;
                    end
                end
                1'b1: begin
                    RS232_reader_clkCnt <= 867;
                    if ((RS232_reader_bitCnt > 0)) begin
                        RS232_reader_data <= ($signed({1'b0, RS232_reader_data}) | ($signed({1'b0, rx}) << (8 - $signed({1'b0, RS232_reader_bitCnt}))));
                        RS232_reader_bitCnt <= (RS232_reader_bitCnt - 1);
                    end
                    else begin
                        fifodata <= RS232_reader_data;
                        fifowe <= 1'b1;
                        RS232_reader_state <= 1'b0;
                    end
                end
            endcase
        end
    end
end


always @(posedge clk, negedge reset) begin: PROCESSOR_RS232_WRITER_LOGIC
    if (reset == 0) begin
        tx <= 1;
        RS232_writer_bitCnt <= 0;
        RS232_writer_state <= 1'b0;
        RS232_writer_clkCnt <= 0;
        RS232_writer_data <= 0;
        rstreadybit <= 1;
    end
    else begin
        if ((RS232_writer_clkCnt > 0)) begin
            RS232_writer_clkCnt <= (RS232_writer_clkCnt - 1);
        end
        else begin
            tx <= 1'b1;
            case (RS232_writer_state)
                1'b0: begin
                    if (enRst) begin
                        RS232_writer_data <= bbus[8-1:0];
                        RS232_writer_clkCnt <= 867;
                        rstreadybit <= 1'b0;
                        RS232_writer_bitCnt <= 8;
                        tx <= 1'b0;
                        RS232_writer_state <= 1'b1;
                    end
                    else begin
                        rstreadybit <= 1'b1;
                    end
                end
                1'b1: begin
                    if ((RS232_writer_bitCnt > 0)) begin
                        tx <= RS232_writer_data[(8 - $signed({1'b0, RS232_writer_bitCnt}))];
                        RS232_writer_bitCnt <= (RS232_writer_bitCnt - 1);
                        RS232_writer_clkCnt <= 867;
                    end
                    else begin
                        tx <= 1'b1;
                        RS232_writer_clkCnt <= 1301;
                        RS232_writer_state <= 1'b0;
                    end
                end
            endcase
        end
    end
end


always @(vOut, zOut, irJumpOp, cOut, nOut) begin: PROCESSOR_JUMPUNIT_JU_LOGIC
    reg result;
    result = 1'b0;
    if (irJumpOp[4]) begin
        result = (result || (zOut != 0));
    end
    if (irJumpOp[3]) begin
        result = (result || (nOut != 0));
    end
    if (irJumpOp[2]) begin
        result = (result || (cOut != 0));
    end
    if (irJumpOp[1]) begin
        result = (result || (vOut != 0));
    end
    if (irJumpOp[0]) begin
        result = (!result);
    end
    jumpResult = result;
end



assign StatusFlags_sUp = (irSup & enSup);


always @(posedge clk, negedge reset) begin: PROCESSOR_STATUSFLAGS_Z_WRITE
    if (reset == 0) begin
        StatusFlags_Z_data <= 0;
    end
    else begin
        if (StatusFlags_sUp) begin
            StatusFlags_Z_data <= zIn;
        end
    end
end



assign zOut = StatusFlags_Z_data;


always @(posedge clk, negedge reset) begin: PROCESSOR_STATUSFLAGS_N_WRITE
    if (reset == 0) begin
        StatusFlags_N_data <= 0;
    end
    else begin
        if (StatusFlags_sUp) begin
            StatusFlags_N_data <= nIn;
        end
    end
end



assign nOut = StatusFlags_N_data;


always @(posedge clk, negedge reset) begin: PROCESSOR_STATUSFLAGS_C_WRITE
    if (reset == 0) begin
        StatusFlags_C_data <= 0;
    end
    else begin
        if (StatusFlags_sUp) begin
            StatusFlags_C_data <= cIn;
        end
    end
end



assign cOut = StatusFlags_C_data;


always @(posedge clk, negedge reset) begin: PROCESSOR_STATUSFLAGS_V_WRITE
    if (reset == 0) begin
        StatusFlags_V_data <= 0;
    end
    else begin
        if (StatusFlags_sUp) begin
            StatusFlags_V_data <= vIn;
        end
    end
end



assign vOut = StatusFlags_V_data;



assign ALU_BmuxOut = irOp2 ? irImm16 : rgY;


always @(rgX, ALU_BmuxOut, enAlu, cOut, irAluop) begin: PROCESSOR_ALU_ALU_LOGIC
    reg [32-1:0] alu_res;
    integer result;
    zIn = 1'b0;
    nIn = 1'b0;
    cIn = 1'b0;
    vIn = 1'b0;
    ALU_aluRes = 0;
    if (enAlu) begin
        result = MYHDL31_calc(irAluop, rgX, ALU_BmuxOut, cOut);
        alu_res = result[32-1:0];
        zIn = (alu_res == 0);
        nIn = alu_res[(32 - 1)];
        cIn = ((result & 34'h100000000) != 0);
        vIn = ((rgX[(32 - 1)] == ALU_BmuxOut[(32 - 1)]) && (rgX[(32 - 1)] == (!alu_res[(32 - 1)])));
        ALU_aluRes = alu_res;
    end
end



assign ALU_aluTristate_o = bufAlu ? ALU_aluRes : 'bz;



assign romrden = (Memory_enO & Memory_csO);



assign ramrden = (Memory_enO & Memory_csA);



assign ramwren = (Memory_enW & Memory_csA);


always @(posedge clk, negedge reset) begin: PROCESSOR_MEMORY_MMU_WRITE
    if (reset == 0) begin
        memoryaddr <= 0;
        Memory_enW <= 0;
        Memory_enO <= 0;
        Memory_Mmu_waitingtimer <= 0;
        Memory_Mmu_state <= 2'b00;
        memoryout <= 0;
        Memory_csA <= 0;
        readybit <= 1;
        Memory_csO <= 0;
        Memory_Mmu_with_data <= 0;
        Memory_Mmu_in_data <= 0;
    end
    else begin
        if (enMmu) begin
            case (Memory_Mmu_state)
                2'b00: begin
                    readybit <= 1'b0;
                    memoryaddr <= bbus[16-1:0];
                    Memory_csA <= bbus[31];
                    Memory_csO <= (!bbus[31]);
                    Memory_Mmu_state <= 2'b01;
                end
                2'b01: begin
                    if ((Memory_csA != 0) !== 1) begin
                        $display("*** AssertionError ***");
                    end
                    Memory_csA <= 1'b1;
                    Memory_csO <= 1'b0;
                    Memory_Mmu_with_data <= 1'b1;
                    Memory_Mmu_in_data <= bbus;
                end
                default: begin
                    $write("Something went wrong! (Did you read the protocoll?)");
                    $write("\n");
                end
            endcase
        end
        else if ((Memory_Mmu_state == 2'b01)) begin
            if ((!(Memory_enO && Memory_enW)) !== 1) begin
                $display("*** AssertionError ***");
            end
            if ((!Memory_Mmu_with_data)) begin
                Memory_enO <= 1'b1;
                if ((Memory_Mmu_waitingtimer == 2)) begin
                    Memory_Mmu_in_data <= memoryin;
                    Memory_Mmu_state <= 2'b10;
                end
            end
            else begin
                Memory_enW <= 1'b1;
                memoryout <= Memory_Mmu_in_data;
                if ((Memory_Mmu_waitingtimer == 2)) begin
                    Memory_Mmu_state <= 2'b10;
                end
            end
				Memory_Mmu_waitingtimer <= (Memory_Mmu_waitingtimer + 1);
		  end	
        else if ((Memory_Mmu_state == 2'b10)) begin
            Memory_Mmu_waitingtimer <= 0;
            Memory_Mmu_with_data <= 1'b0;
            Memory_enO <= 1'b0;
            Memory_enW <= 1'b0;
            readybit <= 1'b1;
            Memory_Mmu_state <= 2'b00;
        end
    end
end


always @(posedge readybit) begin: PROCESSOR_MEMORY_MMU_READ
    Memory_mmuOut <= Memory_Mmu_in_data;
end



assign Memory_mmuTristate_o = mmuBuf ? Memory_mmuOut : 'bz;


always @(posedge clk, negedge reset) begin: PROCESSOR_IR_IR_WRITE
    if (reset == 0) begin
        IR_ir_data <= 0;
    end
    else begin
        if (enIr) begin
            IR_ir_data <= bbus;
        end
    end
end



assign IR_ir2idecoder = IR_ir_data;



assign irAluop = IR_ir2idecoder[25-1:21];
assign irDest = IR_ir2idecoder[29-1:25];
assign irSource = IR_ir2idecoder[21-1:17];
assign irOp1 = IR_ir2idecoder[24];
assign irOp2 = IR_ir2idecoder[16];
assign irSource2 = IR_ir2idecoder[4-1:0];
assign irImm24 = IR_ir2idecoder[24-1:0];
assign irImm16 = IR_ir2idecoder[16-1:0];
assign irSup = IR_ir2idecoder[29];
assign irPrefix = IR_ir2idecoder[32-1:25];
assign irJumpOp = IR_ir2idecoder[30-1:25];


always @(posedge clk, negedge reset) begin: PROCESSOR_IO_IO_LOGIC
    if (reset == 0) begin
        IO_io_ledBuffer <= 0;
        leds <= 15;
        IO_ioOut <= 0;
    end
    else begin
        if (enLed) begin
            IO_io_ledBuffer <= bbus[4-1:0];
        end
        IO_ioOut <= (~buttons);
        leds <= (~IO_io_ledBuffer);
    end
end



assign IO_ioTristate_o = bufBut ? IO_ioOut : 'bz;


always @(addrymux1, addrymux0, irDest, irSource2) begin: PROCESSOR_REGISTERBANK_YMUX_LOGIC
    if ((!addrymux1)) begin
        if ((!addrymux0)) begin
            RegisterBank_yMuxOut = irSource2;
        end
        else begin
            RegisterBank_yMuxOut = 15;
        end
    end
    else begin
        if ((!addrymux0)) begin
            RegisterBank_yMuxOut = 14;
        end
        else begin
            RegisterBank_yMuxOut = irDest;
        end
    end
end


always @(addrymux1, addrymux0, irSource2, irDest) begin: PROCESSOR_REGISTERBANK_ZMUX_LOGIC
    if ((!addrymux1)) begin
        if ((!addrymux0)) begin
            RegisterBank_zMuxOut = irDest;
        end
        else begin
            RegisterBank_zMuxOut = 15;
        end
    end
    else begin
        if ((!addrymux0)) begin
            RegisterBank_zMuxOut = 14;
        end
        else begin
            RegisterBank_zMuxOut = irSource2;
        end
    end
end


always @(posedge clk, negedge reset) begin: PROCESSOR_REGISTERBANK_RB_WRITE
    if (reset == 0) begin
        RegisterBank_rb_reg_data[0] <= 0;
        RegisterBank_rb_reg_data[1] <= 0;
        RegisterBank_rb_reg_data[2] <= 0;
        RegisterBank_rb_reg_data[3] <= 0;
        RegisterBank_rb_reg_data[4] <= 0;
        RegisterBank_rb_reg_data[5] <= 0;
        RegisterBank_rb_reg_data[6] <= 0;
        RegisterBank_rb_reg_data[7] <= 0;
        RegisterBank_rb_reg_data[8] <= 0;
        RegisterBank_rb_reg_data[9] <= 0;
        RegisterBank_rb_reg_data[10] <= 0;
        RegisterBank_rb_reg_data[11] <= 0;
        RegisterBank_rb_reg_data[12] <= 0;
        RegisterBank_rb_reg_data[13] <= 0;
        RegisterBank_rb_reg_data[14] <= 0;
        RegisterBank_rb_reg_data[15] <= 0;
    end
    else begin
        if ((irSource < 16) !== 1) begin
            $display("*** AssertionError ***");
        end
        if ((RegisterBank_yMuxOut < 16) !== 1) begin
            $display("*** AssertionError ***");
        end
        if ((RegisterBank_zMuxOut < 16) !== 1) begin
            $display("*** AssertionError ***");
        end
        if ((enReg && (!(1 && (RegisterBank_zMuxOut == 0))))) begin
            RegisterBank_rb_reg_data[RegisterBank_zMuxOut] <= bbus[32-1:0];
        end
    end
end


always @(RegisterBank_rb_reg_data[0], RegisterBank_rb_reg_data[1], RegisterBank_rb_reg_data[2], RegisterBank_rb_reg_data[3], RegisterBank_rb_reg_data[4], RegisterBank_rb_reg_data[5], RegisterBank_rb_reg_data[6], RegisterBank_rb_reg_data[7], RegisterBank_rb_reg_data[8], RegisterBank_rb_reg_data[9], RegisterBank_rb_reg_data[10], RegisterBank_rb_reg_data[11], RegisterBank_rb_reg_data[12], RegisterBank_rb_reg_data[13], RegisterBank_rb_reg_data[14], RegisterBank_rb_reg_data[15], irSource, RegisterBank_yMuxOut) begin: PROCESSOR_REGISTERBANK_RB_READ
    if ((irSource < 16) !== 1) begin
        $display("*** AssertionError ***");
    end
    if ((RegisterBank_yMuxOut < 16) !== 1) begin
        $display("*** AssertionError ***");
    end
    if ((RegisterBank_yMuxOut < 16) !== 1) begin
        $display("*** AssertionError ***");
    end
    rgX = RegisterBank_rb_reg_data[irSource];
    rgY = RegisterBank_rb_reg_data[RegisterBank_yMuxOut];
end



assign RegisterBank_ryTristate_o = bufRy ? rgY : 'bz;



assign Op2Buf_op2muxOut = irOp1 ? irImm24 : rgY;



assign Op2Buf_op2tristate_o = bufOp2 ? Op2Buf_op2muxOut : 'bz;

endmodule
