In unserem Pojekt haben wir an vielfältigen Stellen auf die Sprache Python zurückgegriffen. Python wurde sowohl zu Modellierungsunterstüzung als auch zum Bau von Emulatoren und UIs verwendet. Diese waren zwar nicht zwingend relevant für das Abschließen des Projektes, erleichterten unsere Arbeit allerdings sehr. \newline
Die Entscheidung für die Sprache Python wurde in unserer Gruppe sehr früh getroffen. Schon beim ersten Treffen waren alle Gruppenmitgleider ausreichend über VHDL Vor- und vorallem Nachteile informiert, um eine Wrapper-Sprache ausprobieren zu wollen. Bereits beim ersten Treffen haben wir beschlossen, dass wir Python nicht nur nutzen wollen, weil die Sprache intuitiv ist, sondern weil wir ein Python Package fanden, dass den gesamten Hardware-Modellierungsprozess von VHDL auf Python Konstrukte abstrahieren konnte - MyHDL. Mit diesem Package konnte die Modellierungsarbeit und später auch die Verifikation erheblich erleichtert werden. MyHDL bildet eine Art Brücke zwischen den Eigenheiten der mit VHDL möglichen Prozessbeschreibung hin zu dem bekannten Pythonkonzept der Generatoren. Mit Pythons Unit Test Framework war es viel leichter den MyHDL Code zu testen, als tatsächliche Hardwaretests durchzuführen. Zumindest in den frühen Stadien des Projektes hat es einen großen Teil der Arbeit sehr erleichtert. \newline
Abgesehen von dem Wrapper-Package MyHDL hat die Sprache Python noch an anderen Stellen viel Einfluss auf unser Projekt gehabt. Als erstes war ein Compiler für unseren eigenen Assembler wichtig. Wir wollten unsere Assembler Befehle in Bitcode übersetzen können. Dieser Assembler wurde in Python geschrieben und übersetzt alle Assemblerbefehlsworte in den Bitcode, wie er in userer \todo{Link ISA here!!} ISA spezifiziert ist. Mit dem Bitcode war allerdings noch nicht viel anzufangen, da die Hardwarespezifikation noch lange nicht fertig war. Folglich brauchten wir eine Möglichkeit, unsere Assemblerprogramme auf Gültigkeit zu testen, am besten sogar eine Ausführungsmöglichkeit. Es folgte ein weiteres kleines Unterprojekt in Python. \newline
Wir haben uns zum Ziel gesetzt, einen Emulator zu schreiben, der den später modellierten Microcontroller vollständig widerspiegeln sollte. Damit wollten wir es uns ermöglichen, bereits kleine Programme in unserem eigenem Assembler-Code schreiben und ausprobieren zu können. Den Emulator haben wir ebenfalls in Python geschrieben, er emuliert analog zur HDL Hardwarestruktur eine CPU, eine RAM/ROM und einen Programmcode in der ROM. Auf dieser Ausführungseinheit fehlte nur noch die Introspektion, die wir brauchten, um den Ablauf der Programme zu verifizieren und auch Datenflüsse in der emulierten Hardware zu optimieren. Da wir den Emulator eng an die tatsächliche Hardwarespezifikation angelehnt haben, war es uns möglich das spätere Verhalten des Microcontrollers am Beispiel des Emulators zu beobachten und zu verbessern. Um also den nötigen Grad an Einsicht in unsere Programminterna zu erhalten, schrieben wir unsere eigene \glqq Emulator UI'', eine Art Debugger für Programm- und Hardwarezustände. Für das grafische Frontend des Emulators verwendeten wir das UI-Framework GTK für Python.

